#' SMuRF v3.0.0
#'
#' Somatic mutation consensus calling based on five callers:
#' MuTect2, Freebayes, VarDict, VarScan and Strelka2
#' using a RandomForest model to consolidate a list of high accuracy calls.
#'
#' @note
#' Input files containing variant calls should be ".vcf.gz" format of each caller.
#' Supported for R >= 3.5.0, Java version 7 (up to 11) is supported. 
#' 
#' @param directory Choose directory where the Variant Caller Format(VCF) files are located. 
#' Alternatively, provide a list object containing the path to the 5 VCF files labeled: mutect, freebayes, vardict, varscan and strelka.
#'
#' @param mode Choose "snv", "indel" or "combined" (snv+indel). 
#' The appropriate parsing and prediction model will be performed
#' to obtain a list of somatic mutation calls. 
#' 
#' Debug mode: Choose "featureselectionall" to parse the VCF files only.
#' 
#' @param build Genome build='hg19' or "hg38". Please specify.
#' 
#' @param nthreads Default as "-1", where all available cores will be used for RandomForest prediction. 
#' Specify any integer from 1 to x, depending on your resources available.
#' For 32-bit Windows, only 1 core is allowed (nthreads=1).
#' 
#' @param annotation TRUE or FALSE (default). Provide gene annotations for each variant call.
#' 
#' @param snv.cutoff Default SNV model cutoff, 0.351791676448298 in SMuRF v3.0.0,  unless a number between 0 to 1 is stated. 
#' 
#' @param indel.cutoff Default indel model cutoff, 0.206274634032831 in SMuRF v3.0.0, unless a number between 0 to 1 is stated.
#' 
#' @param output.dir Path to output directory (if saving files as .txt)
#' 
#' @param parse.dir Specify if changing SMuRF default cutoffs in the future.
#' Path to the location of existing snv-parse.txt and indel-parse.txt files generated by SMuRF. 
#' 
#' @param change.build TRUE or FALSE. For conversion of your genomic coordinates.
#' Default option is disabled to retain your original 'build' specified above. 
#' 
#' @param find.build Default as FALSE. Additional genome build check for the annotation step.
#' Retrieves the reference genome from the Strelka2 vcf header info to cross check with the build stated by the user. 
#' 
#' @param t.label (optional) Provide the sample name for your tumour sample to ease 
#' the identification of the normal and tumour sample names in your vcf.
#' See examples below
#' 
#' @param re.tabIndex Default as FALSE. Set to TRUE if tab-indexed (.tbi) files for each vcf is missing.
#' 
#' @param check.packages Default as TRUE. For debug mode.
#' 
#' @param file.exclude Additional keywords in file directory names to be filtered.
#' @export
#' @examples
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="indel",build='hg19')
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="snv",build='hg19',
#'                   output.dir="/path/to/output")
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined",build='hg19',
#'                   nthreads = 4,
#'                   snv.cutoff = 0.2, indel.cutoff = 'default')
#' 
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, build='hg19')
#' 
#' #Change hg38 to hg19 coordinates in gene annotation output
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, 
#'                   build='hg38', change.build=T)
#'                   
#' #Specify tumor sample name
#' myresults = smurf(directory="/path/to/directory..",
#'                   mode="combined", 
#'                   annotation=T, 
#'                   build='hg38', t.label = '-T')
#'                                       
#' #Specify directories manually
#' dir.list = list(mutect='/path/to/mutect.vcf.gz',
#'                 freebayes='/path/to/freebayes.vcf.gz',
#'                 vardict='/path/to/vardict.vcf.gz',
#'                 varscan='/path/to/varscan.vcf.gz',
#'                 strelka='/path/to/strelka.vcf.gz')
#'                 
#' myresults = smurf(directory=dir.list, 
#'                   model="combined",build='hg19')
#'                                    

smurf = function(directory=NULL, mode=NULL, nthreads = -1,
                 annotation=F, output.dir=NULL, parse.dir=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 build=NULL, change.build=F, find.build=F,
                 t.label=NULL, re.tabIndex=F,
                 check.packages=T, file.exclude=NULL){
  
  #SMuRF version announcement
  print("SMuRFv3.0.0, Jan 2024")
  suppressWarnings(suppressMessages(library(data.table)))
  if(is.null(directory)){
    # stop('directory path not specified')
    return(write("smurf(directory=NULL, mode=NULL, nthreads = -1,
                 annotation=F, output.dir=NULL,  parse.dir=NULL,
                 snv.cutoff = 'default', indel.cutoff = 'default',
                 build=NULL, change.build=F, find.build=F,
                 t.label=NULL, re.tabIndex=F,
                 check.packages=T, file.exclude=NULL)", stdout()))
  }
  
  if(!is.null(directory) & class(directory)!='list'){
    if(dir.exists(directory)==F){
      stop('directory path does not exist')
    }
  }
  
  if(snv.cutoff != 'default' & (snv.cutoff < 0 | snv.cutoff > 1) ){
    stop('snv.cutoff out of range')
  }
  
  if(indel.cutoff != 'default' & (indel.cutoff < 0 | indel.cutoff > 1) ){
    stop('indel.cutoff out of range')
  }
  
  if (!is.null(output.dir)) {
    if(dir.exists(output.dir)==F){
      print(paste0('Creating output dir: ',output.dir))
      dir.create(output.dir)
      save.files = T
    } else {
      print(paste0('Saving output files to: ',output.dir))
      save.files = T
    }
  } else {
    save.files = F
  }
  
  
  if(is.null(build) & annotation == T){
    stop('Please specify genome build. build = "hg19" or "hg38".')
  }
  
  if (!is.null(build) & annotation == T) {
    if (build!='hg19' & build!='hg38') {
      stop('build unrecognized. Only hg19 or hg38 is allowed.')
    }
  }
  
  
  if (class(directory)!='list') {
    
    mutect2 <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz"))
    freebayes <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz"))
    varscan <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz"))
    vardict <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz"))
    strelka2 <- Sys.glob(paste0(directory,"/*strelka*.vcf.gz"))
    
    # germline file filter
    # warning('VCF file names containing "germline" will be excluded.')
    
    keywords=c("germline")
    if(!is.null(file.exclude)){
      keywords = c(keywords, file.exclude)
    }
    
    dir.check = function(dir.name,caller,keywords) {
      key.len = length(keywords)
      if(length(dir.name)!=1){
        print(paste('Two file names for', caller, 'detected.'))
        for (k in 1:key.len) {
        if(length(grep(keywords[k],dir.name))==1){
          dir.name = dir.name[-grep(keywords[k], dir.name)]
      }
        }
        if(length(dir.name)==1){
          print(paste('Selecting',dir.name))
        }
      }
      if(length(dir.name)!=1){
        print(dir.name)
        warning('More than one file is selected. Use file.exclude to specify unique file name.')
      } 
      return(dir.name)
    }
    
    mutect2 = dir.check(mutect2,'MuTect2', keywords)
    freebayes = dir.check(freebayes,'FreeBayes', keywords)
    varscan = dir.check(varscan,'VarScan', keywords)
    vardict = dir.check(vardict,'VarDict', keywords)
    strelka2 = dir.check(strelka2,'Strelka2', keywords)
    
    if(length(mutect2)!=1 |
       length(freebayes)!=1 |
       length(varscan)!=1 |
       length(vardict)!=1 |
       length(strelka2)!=1) {
      stop('Directory contains missing or duplicated vcf files. Alternatively, you may specify your path to caller files as a list object manually.')
    }
    
    # germline file filter
    # warning('VCF file names containing "germline" will be excluded.')
    
    # if(length(grep("strelka", strelka2))!=1) {
    #   warning('Strelka2 VCF not detected correctly. Use SMuRFv1.6 for 4 callers: Mutect2, Freebayes, Vardict, Varscan.')
    # }
    
    x<-list(mutect2,freebayes,varscan,vardict,strelka2)

  } else if (class(directory)=='list'){
    x = directory
    if (length(x)!=5){
      stop('Input file check failed. Directory contains incorrect number of vcf files.')
    }
  }
  
  
  if(re.tabIndex == F) {
    
      mutect2.tbi <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz.tbi"))
      freebayes.tbi <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz.tbi"))
      varscan.tbi <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz.tbi"))
      vardict.tbi <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz.tbi"))
      strelka2.tbi <- Sys.glob(paste0(directory,"/*strelka*.vcf.gz.tbi"))
      
      # germline file filter
      # warning('VCF file names containing "germline" will be excluded.')
      
      mutect2.tbi = dir.check(mutect2.tbi,'MuTect2', keywords)
      freebayes.tbi = dir.check(freebayes.tbi,'FreeBayes', keywords)
      varscan.tbi = dir.check(varscan.tbi,'VarScan', keywords)
      vardict.tbi = dir.check(vardict.tbi,'VarDict', keywords)
      strelka2.tbi = dir.check(strelka2.tbi,'Strelka2', keywords)
      
      
    tbi<-list(mutect2.tbi,freebayes.tbi,varscan.tbi,vardict.tbi,strelka2.tbi)
    
    if (length(mutect2.tbi)!=1 |
        length(freebayes.tbi)!=1 |
        length(varscan.tbi)!=1 |
        length(vardict.tbi)!=1 |
        length(strelka2.tbi)!=1|
        length(tbi)!=5){
      print('tab-indexed (.tbi) files required not found.')
      stop('Specify re.tabIndex=TRUE to re-index your vcf files.')
    }
    
    } else if (re.tabIndex == T){
      
      print('Generating .tbi files in directory...')
      
      library(Rsamtools)
      indexTabix(x[[1]], format = 'vcf')
      indexTabix(x[[2]], format = 'vcf')
      indexTabix(x[[3]], format = 'vcf')
      indexTabix(x[[4]], format = 'vcf')
      indexTabix(x[[5]], format = 'vcf')
      
      mutect2.tbi <- Sys.glob(paste0(directory,"/*mutect*.vcf.gz.tbi"))
      freebayes.tbi <- Sys.glob(paste0(directory,"/*freebayes*.vcf.gz.tbi"))
      varscan.tbi <- Sys.glob(paste0(directory,"/*varscan*.vcf.gz.tbi"))
      vardict.tbi <- Sys.glob(paste0(directory,"/*vardict*.vcf.gz.tbi"))
      strelka2.tbi <- Sys.glob(paste0(directory,"/*strelka*.vcf.gz.tbi"))
      
      # germline file filter
      # warning('VCF file names containing "germline" will be excluded.')
      mutect2.tbi = dir.check(mutect2.tbi,'MuTect2', keywords)
      freebayes.tbi = dir.check(freebayes.tbi,'FreeBayes', keywords)
      varscan.tbi = dir.check(varscan.tbi,'VarScan', keywords)
      vardict.tbi = dir.check(vardict.tbi,'VarDict', keywords)
      strelka2.tbi = dir.check(strelka2.tbi,'Strelka2', keywords)
      
      tbi<-list(mutect2.tbi,freebayes.tbi,varscan.tbi,vardict.tbi,strelka2.tbi)
      
    }

      
  if(is.null(mode)){
    stop('mode is not provided')
}
  if (mode != "combined" & 
        mode != "snv" & 
        mode != "indel" & 
        mode != "featureselectionall"
    ) {
      stop('mode unrecognized')
    }
  
  
  
  #check for existing and required packages
    
  if(check.packages == T) {
    if (getRversion()<3.5) {
    
    if("VariantAnnotation" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("VariantAnnotation")
    }
    
    if("Rsamtools" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("Rsamtools")
    }
      
    if("rtracklayer" %in% rownames(installed.packages()) == FALSE){
      source("https://bioconductor.org/biocLite.R")
      biocLite("rtracklayer")
    }
      
    } else { #R>=3.5
      
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    BiocManager::install()
    BiocManager::install(c("VariantAnnotation"))
    }
    
    }
  }
  
  if (! ("data.table" %in% rownames(installed.packages()))) { install.packages("data.table") }
  if (! ("methods" %in% rownames(installed.packages()))) { install.packages("methods") }
  # if (! ("statmod" %in% rownames(installed.packages()))) { install.packages("statmod") }
  if (! ("stats" %in% rownames(installed.packages()))) { install.packages("stats") }
  if (! ("graphics" %in% rownames(installed.packages()))) { install.packages("graphics") }
  if (! ("RCurl" %in% rownames(installed.packages()))) { install.packages("RCurl") }
  if (! ("jsonlite" %in% rownames(installed.packages()))) { install.packages("jsonlite") }
  if (! ("tools" %in% rownames(installed.packages()))) { install.packages("tools") }
  if (! ("utils" %in% rownames(installed.packages()))) { install.packages("utils") }
  if (! ("dplyr" %in% rownames(installed.packages()))) { install.packages("dplyr") }
  #installs latest stable version of h2o
  if (! ("h2o" %in% rownames(installed.packages()))) { install.packages("h2o", type="source", repos=(c("http://h2o-release.s3.amazonaws.com/h2o/rel-yu/1/R"))) }
  

    #load packages
  
    suppressWarnings(suppressMessages(library(VariantAnnotation)))

    suppressWarnings(suppressMessages(library(h2o)))
    
    #nthreads = -1
    if(exists('nthreads')==F) {nthreads = -1}
    suppressWarnings(h2o.init(nthreads = nthreads))
      
    
    #check/match ref genome build
    
    print('Genome build stated in SMuRF:')
    print(build)
    if (build=='hg19') {
      g.build = 'GRCh37'
    } else {
      g.build = build
    }
    print('Ref genome used in vcf:')
    genomebuild = suppressWarnings(scanVcfHeader(x[[5]])@header@listData$reference$Value)
    match.build = grep(g.build,genomebuild)
    print(genomebuild)
    
    if ( annotation==T && (is.null(genomebuild) || length(match.build)==0) ) {
      print('Warning: build provided does not match ref genome used in vcf. SMuRF CDS annotation may not run properly if genome build is incorrect.')
    } 
    if (!is.null(genomebuild) && length(match.build)==0 && find.build==T && annotation==T){
      find.hg19 = grep('GRCh37',genomebuild)
      find.hg38 = grep('hg38',genomebuild)
      if ( length(find.hg19)==0 && length(find.hg38)!=0 && build=='hg19' ) {
        print('Changing build variable provided')
        print('hg19 -> hg38')
        build='hg38'
      } else if ( length(find.hg19)!=0 && length(find.hg38)==0 && build=='hg38') {
        print('Changing build variable provided')
        print('hg38 -> hg19')
        build='hg19'
      }
    } else if (is.null(genomebuild) && find.build==T && annotation==T){
      print('Changing build variable provided')
      warning('ref genome used in vcf not found. find.build==T skipped.')
    }
    
    print(paste0('Final genome build used for analysis: ',build))
    
    
    #Retrieving files from the directory
    
    write("Accessing files:", stdout())
    write(mutect2, stdout())
    write(freebayes, stdout())
    write(varscan, stdout())
    write(vardict, stdout())
    write(strelka2, stdout())
    
    start.time <- Sys.time()
    
    #### parse.dir ####

    if (!is.null(parse.dir)) {
      if(dir.exists(parse.dir)==F){
        stop('parse.dir path does not exist. Assigning newcutoff requires path to parse.txt files')
      } else {
        
        myresults = newcutoffs(parse.dir,
                               snv.cutoff, indel.cutoff)
        

        if (annotation == F) {
          
          if (save.files == T) {
            
            save.files(myresults,
                       output.dir)
          }else{
          
          return(myresults)}
          
        } else if (annotation == T) {
          
          if (nrow(snvpredict$predicted_snv)>1 && !is.null(snvpredict$predicted_snv)) {
            print("SNV annotation")
            snvannotation<-CDSannotation_snv(x,myresults$smurf_snv$predicted_snv,build=build,change.build=change.build)
          } else {
            print("No snv predictions. Skipping snv annotation step.")
            snvannotation=NULL
          }
          
          if (nrow(indelpredict$predicted_indel)>1 && !is.null(indelpredict$predicted_indel)) {
            print("Indel annotation")
            indelannotation<-CDSannotation_indel(x,myresults$smurf_indel$predicted_indel,build=build,change.build=change.build)
          } else {
            print("No indel predictions. Skipping indel annotation step.")
            indelannotation=NULL
          }
          
          end.time <- Sys.time()
          time.taken <- end.time - start.time
          print(time.taken)
          
          if (save.files == T) {
            
            save.files(myresults,
                       output.dir)
            
            save.files(myresults=list("smurf_snv_annotation"=snvannotation,
                                      "smurf_indel_annotation"=indelannotation,
                                      "time.taken"=time.taken),
                       output.dir)
          }else{
          
          return(list(myresults, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
	  }
        }
        
      }
    }
    
    #### snv ####            

    if (mode == "snv") {
      
        parsevcf<-parsevcf_allfeaturesall(x,tbi, t.label=t.label)
        snvpredict<-snvRFpredict(parsevcf, snv.cutoff)

      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    # "smurf_indel"=indelpredict,
                                    "time.taken"=time.taken),
                     output.dir)
        }else{
        
        return(list("smurf_snv"=snvpredict, "time.taken"=time.taken))
	}
      
      } else if (annotation == T) {
        
        if (nrow(snvpredict$predicted_snv)>1 && !is.null(snvpredict$predicted_snv)) {
          print("SNV annotation")
          snvannotation<-CDSannotation_snv(x,tbi,snvpredict,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snvannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    # "smurf_indel"=indelpredict,
                                    "smurf_snv_annotation"=snvannotation,
                                    # "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }else{
        
        return(list("smurf_snv"=snvpredict, "smurf_snv_annotation"=snvannotation, "time.taken"=time.taken))
         }
        }
      
      #### indel ####            
      
      } else if (mode == "indel") {
      
          parsevcf<-parsevcf_allfeaturesall(x,tbi, t.label=t.label)
          indelpredict<-indelRFpredict(parsevcf, indel.cutoff)

      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          save.files(myresults=list(#"smurf_snv"=snvpredict,
            "smurf_indel"=indelpredict,
            "time.taken"=time.taken),
            output.dir)
        }else{
        
        return(list("smurf_indel"=indelpredict, "time.taken"=time.taken))
	}
        
      } else if (annotation == T) {
        
        if (nrow(indelpredict$predicted_indel)>1 && !is.null(indelpredict$predicted_indel)) {
          print("Indel annotation")
          indelannotation<-CDSannotation_indel(x,tbi,indelpredict,build=build,change.build=change.build)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indelannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list(#"smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    # "smurf_snv_annotation"=snvannotation,
                                    "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }else{
        
        
        return(list("smurf_indel"=indelpredict, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
	}
      }

      #### combined ####            

      } else if (mode == "combined") {
      
          parsevcf<-parsevcf_allfeaturesall(x,tbi, t.label=t.label)
          snvpredict<-snvRFpredict(parsevcf, snv.cutoff)
          indelpredict<-indelRFpredict(parsevcf, indel.cutoff)

      if (annotation == F) {
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "time.taken"=time.taken),
                     output.dir)
        }else{
      
      return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "time.taken"=time.taken))
	}

      } else if (annotation == T) {
        
        if (nrow(snvpredict$predicted_snv)>1 && !is.null(snvpredict$predicted_snv)) {
          print("SNV annotation")
          snvannotation<-CDSannotation_snv(x,tbi,snvpredict,build=build,change.build=change.build)
        } else {
          print("No snv predictions. Skipping snv annotation step.")
          snvannotation=NULL
        }
        
        if (nrow(indelpredict$predicted_indel)>1 && !is.null(indelpredict$predicted_indel)) {
          print("Indel annotation")
          indelannotation<-CDSannotation_indel(x,tbi,indelpredict,build=build,change.build=change.build)
        } else {
          print("No indel predictions. Skipping indel annotation step.")
          indelannotation=NULL
        }
        
        end.time <- Sys.time()
        time.taken <- end.time - start.time
        print(time.taken)
        
        if (save.files == T) {
          
          save.files(myresults=list("smurf_snv"=snvpredict,
                                    "smurf_indel"=indelpredict,
                                    "smurf_snv_annotation"=snvannotation,
                                    "smurf_indel_annotation"=indelannotation,
                                    "time.taken"=time.taken),
                     output.dir)
        }else{
        
        return(list("smurf_snv"=snvpredict, "smurf_indel"=indelpredict, "smurf_snv_annotation"=snvannotation, "smurf_indel_annotation"=indelannotation, "time.taken"=time.taken))
	}
      }

      #### featureselectionall ####            

    } else if (mode == "featureselectionall") { #debug mode, only parse feature matrix
      
      parsevcf<-parsevcf_allfeaturesall(x, tbi, t.label=t.label)
      
      end.time <- Sys.time()
      time.taken <- end.time - start.time
      print(time.taken)
      
      if (save.files == T) {
        save.files(myresults=list("parsevcf_featureselection"=parsevcf,
                                  "time.taken"=time.taken),
                   output.dir)
      }else{
      
      return(list("parsevcf_featureselection"=parsevcf, "time.taken"=time.taken))
      }
    }
    
    # write("DONE",stdout())
    
}
